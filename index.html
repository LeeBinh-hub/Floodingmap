<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Floodingmap - WebSocket</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- ApexCharts -->
<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>

<style>
  body { margin:0; padding:0; font-family:Arial; }
  #map { width: 100vw; height: 100vh; }

  /* SIDEBAR */
  #sidebar {
    position: fixed; top:0; right:-420px; width:420px; height:100vh;
    background:#fff; border-left:3px solid #000; box-shadow:-4px 0 25px rgba(0,0,0,0.15);
    transition:0.35s; z-index:9999; display:flex; flex-direction:column;
  }
  #sidebar.active { right:0; }
  #sidebarHeader {
    background: linear-gradient(135deg,#0078ff,#00a6ff); color:white; padding:16px;
    font-size:20px; font-weight:bold; display:flex; justify-content:space-between; align-items:center;
  }
  #closeBtn { cursor:pointer; font-size:22px; padding:2px 8px; background:rgba(255,255,255,0.3); border-radius:4px; }
  #sidebarContent { padding:20px; overflow-y:auto; }

  #toggleSidebar {
    position: fixed; top:20px; right:20px; background:#0078ff; color:white; padding:14px; border-radius:50%;
    cursor:pointer; z-index:10000; box-shadow:0 4px 10px rgba(0,0,0,0.25); font-size:20px;
  }
  #searchBox { position: fixed; top:20px; left:20px; z-index:10000; }
  #searchInput {
    width:260px; padding:10px 14px; border-radius:10px; border:2px solid #0078ff; font-size:16px; outline:none;
  }
  .marker-value {
    font-weight:bold;
  }
</style>
</head>
<body>

<div id="toggleSidebar">‚ò∞</div>
<div id="searchBox">
  <input id="searchInput" placeholder="T√¨m ƒëi·ªÉm ƒëo..." />
</div>

<div id="map"></div>

<div id="sidebar">
  <div id="sidebarHeader">
    Chi ti·∫øt ƒëi·ªÉm ƒëo
    <span id="closeBtn">‚úï</span>
  </div>
  <div id="sidebarContent">
    <h2 id="sensorName"></h2>
    <div id="gaugeBox"></div>
    <p id="statusText"></p>
    <div id="chartBox" style="margin-top:25px;"></div>
    <div style="margin-top:12px;"><small id="lastUpdated"></small></div>
  </div>
</div>

<script>
/* ===========================
   C·∫§U H√åNH - Thay WS_URL = IP c·ªßa ESP32
   =========================== */
const WS_URL = "ws://192.168.1.50:81/"; // <-- S·ª≠a l·∫°i IP:port c·ªßa ESP32 t·∫°i ƒë√¢y

/* ===========================
   DANH S√ÅCH ƒêI·ªÇM ƒêO (ban ƒë·∫ßu)
   feed ph·∫£i kh·ªõp v·ªõi ESP32/Adafruit feed n·∫øu b·∫°n d√πng c√πng t√™n
   =========================== */
const SENSORS = [
  { name: "C·∫ßu R·ªìng", feed: "iotproject.mucnuoc1", lat: 16.0605, lng: 108.2237, max_level: 100, warning: 60, danger: 85 },
  { name: "C·∫ßu S√¥ng H√†n", feed: "iotproject.mucnuoc2", lat: 16.0678, lng: 108.2301, max_level: 100, warning: 60, danger: 85 }
];

/* ===========================
   MAP INIT
   =========================== */
const map = L.map('map').setView([16.0678, 108.2200], 13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

/* ===========================
   MARKERS, CACHE, HISTORY
   =========================== */
const markerMap = {};      // feed -> marker
const sensorCache = {};    // feed -> {value, name, timestamp}
const history = {};        // feed -> [ {value, timestamp}, ... ]
const HISTORY_MAX = 50;
let influenceLayers = {};  // feed -> [circle,..]

// t·∫°o marker cho m·ªói ƒëi·ªÉm
SENSORS.forEach(point => {
  const m = L.circleMarker([point.lat, point.lng], {
    radius: 10,
    color: "#0078ff",
    fillColor: "#00a6ff",
    fillOpacity: 0.9
  }).addTo(map);

  m.on("click", () => openSensor(point));
  markerMap[point.feed] = m;
  history[point.feed] = []; // init history
});

/* ===========================
   SIDEBAR UI HELPERS
   =========================== */
const sidebar = document.getElementById("sidebar");
const toggleBtn = document.getElementById("toggleSidebar");
const closeBtn = document.getElementById("closeBtn");

toggleBtn.onclick = () => toggleSidebar();
closeBtn.onclick = () => toggleSidebar(false);

function toggleSidebar(forceOpen = null) {
  if (forceOpen === true) { sidebar.classList.add("active"); return; }
  if (forceOpen === false) { sidebar.classList.remove("active"); return; }
  sidebar.classList.toggle("active");
}

/* ===========================
   GAUGE / STATUS / CHART
   =========================== */
function renderGauge(point, value) {
  const percent = Math.round(value / point.max_level * 100);
  document.getElementById("gaugeBox").innerHTML = `
    <h3>M·ª±c n∆∞·ªõc: <span class="marker-value">${value} cm</span></h3>
    <h1 style="color:#0078ff; font-size:40px">${percent}%</h1>
  `;
}

function renderStatus(point, value) {
  let text, color;
  if (value >= point.danger) { text = "‚ö†Ô∏è Nguy hi·ªÉm"; color = "red"; }
  else if (value >= point.warning) { text = "üü° C·∫£nh b√°o"; color = "orange"; }
  else { text = "üü¢ An to√†n"; color = "green"; }

  document.getElementById("statusText").innerHTML =
    `<span style="color:${color}; font-size:18px; font-weight:bold;">${text}</span>`;
}

function renderChart(feed) {
  const hist = history[feed] || [];
  const values = hist.map(d => d.value).reverse();
  const times = hist.map(d => (new Date(d.timestamp)).toLocaleTimeString()).reverse();

  document.getElementById("chartBox").innerHTML = "";

  new ApexCharts(document.getElementById("chartBox"), {
    chart: { type: "line", height: 260, animations: {enabled: true} },
    series: [{ name: "M·ª±c n∆∞·ªõc", data: values }],
    xaxis: { categories: times },
    stroke: { width: 3 }
  }).render();
}

/* ===========================
   V√íNG TR√íN ·∫¢NH H∆Ø·ªûNG GRADIENT
   =========================== */
function renderInfluence(point, value) {
  // X√≥a c≈©
  if (influenceLayers[point.feed]) {
    influenceLayers[point.feed].forEach(c => map.removeLayer(c));
  }
  const layers = [];
  const steps = 8;
  const maxRadius = 100 + (value / point.max_level) * 400;

  for (let i=1;i<=steps;i++){
    const radius = (i / steps) * maxRadius;
    const opacity = 0.4 * (1 - i / steps);
    let color;
    if (value >= point.danger) color = `rgba(255,0,0,${opacity})`;
    else if (value >= point.warning) color = `rgba(255,165,0,${opacity})`;
    else color = `rgba(0,128,255,${opacity})`;

    const circle = L.circle([point.lat, point.lng], {
      radius: radius,
      color: color,
      fillColor: color,
      fillOpacity: opacity,
      weight: 1
    }).addTo(map);

    layers.push(circle);
  }
  influenceLayers[point.feed] = layers;
}

/* ===========================
   M·ªû SIDEBAR KHI CLICK MARKER (d√πng cache)
   =========================== */
async function openSensor(point) {
  toggleSidebar(true);
  document.getElementById("sensorName").innerText = point.name;

  const cached = sensorCache[point.feed];
  if (cached) {
    renderGauge(point, cached.value);
    renderStatus(point, cached.value);
    renderInfluence(point, cached.value);
    document.getElementById("lastUpdated").innerText = `C·∫≠p nh·∫≠t: ${new Date(cached.timestamp).toLocaleString()}`;
    renderChart(point.feed);
  } else {
    // n·∫øu ch∆∞a c√≥ d·ªØ li·ªáu: hi·ªÉn th·ªã loading placeholder
    document.getElementById("gaugeBox").innerHTML = `<i>ƒêang ch·ªù d·ªØ li·ªáu realtime...</i>`;
    document.getElementById("statusText").innerHTML = ``;
    document.getElementById("chartBox").innerHTML = ``;
    document.getElementById("lastUpdated").innerText = "";
  }
}

/* ===========================
   T√åM KI·∫æM
   =========================== */
document.getElementById("searchInput").addEventListener("input", function () {
  const keyword = this.value.toLowerCase();
  const found = SENSORS.find(s => s.name.toLowerCase().includes(keyword));
  if (!found) return;
  map.setView([found.lat, found.lng], 15);
  openSensor(found);
});

/* ===========================
   WebSocket CONNECTION & HANDLING
   =========================== */
let socket = null;
let reconnectTimer = null;
const RECONNECT_DELAY = 3000;

function connectWS() {
  try {
    socket = new WebSocket(WS_URL);

    socket.onopen = () => {
      console.log("WebSocket connected to", WS_URL);
      if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
      // B·∫°n c√≥ th·ªÉ g·ª≠i 1 message y√™u c·∫ßu server g·ª≠i t·∫•t c·∫£ tr·∫°ng th√°i ban ƒë·∫ßu
      // socket.send(JSON.stringify({ action: "get_all" }));
    };

    socket.onmessage = (evt) => {
      handleWSMessage(evt.data);
    };

    socket.onclose = (evt) => {
      console.warn("WebSocket closed.", evt);
      scheduleReconnect();
    };

    socket.onerror = (err) => {
      console.error("WebSocket error", err);
      // socket.close(); // s·∫Ω trigger onclose
    };
  } catch (e) {
    console.error("WS connect error", e);
    scheduleReconnect();
  }
}

function scheduleReconnect() {
  if (reconnectTimer) return;
  reconnectTimer = setTimeout(() => {
    reconnectTimer = null;
    console.log("Reconnecting WebSocket...");
    connectWS();
  }, RECONNECT_DELAY);
}

/* ===========================
   X·ª¨ L√ù TIN NH·∫ÆN T·ª™ ESP32
   - H·ªó tr·ª£ JSON: {feed, name, value, timestamp}
   - Ho·∫∑c {name, value} / ƒë∆°n gi·∫£n '45' (c·ªë g·∫Øng parse)
   =========================== */
function handleWSMessage(raw) {
  let obj = null;

  try {
    obj = JSON.parse(raw);
  } catch (e) {
    // n·∫øu kh√¥ng ph·∫£i json, th·ª≠ parse s·ªë
    const num = parseFloat(raw);
    if (!isNaN(num)) {
      // n·∫øu nh·∫≠n s·ªë thu·∫ßn, c·∫ßn bi·∫øt feed n√†o - b·ªè qua tr·ª´ khi ESP32 g·ª≠i feed c√πng message
      console.warn("Nh·∫≠n s·ªë thu·∫ßn t·ª´ WS, c·∫ßn format JSON ƒë·ªÉ bi·∫øt feed:", raw);
      return;
    } else {
      console.warn("Kh√¥ng parse ƒë∆∞·ª£c message WS:", raw);
      return;
    }
  }

  // chu·∫©n hi·ªán t·∫°i: obj.feed, obj.name, obj.value, obj.timestamp
  const feed = obj.feed || null;
  const name = obj.name || null;
  const value = (obj.value !== undefined) ? parseFloat(obj.value) : null;
  const timestamp = obj.timestamp ? new Date(obj.timestamp).toISOString() : (new Date()).toISOString();

  if (!feed && name) {
    // t√¨m feed theo t√™n n·∫øu feed kh√¥ng c√≥
    const s = SENSORS.find(x => x.name === name);
    if (s) {
      sFeed = s.feed;
    }
  }

  if (!feed) {
    // N·∫øu kh√¥ng c√≥ feed, c·ªë g·∫Øng d√≤ b·∫±ng name
    const s = SENSORS.find(x => x.name === name);
    if (s) {
      processSensorUpdate(s.feed, name || s.name, value, timestamp);
    } else {
      console.warn("Kh√¥ng x√°c ƒë·ªãnh feed cho message:", obj);
    }
  } else {
    processSensorUpdate(feed, name, value, timestamp);
  }
}

/* ===========================
   C·∫¨P NH·∫¨T CACHE, MARKER, L·ªäCH S·ª¨, UI
   =========================== */
function processSensorUpdate(feed, name, value, timestamp) {
  if (value === null || isNaN(value)) {
    console.warn("Value invalid", feed, value);
    return;
  }

  // update cache
  sensorCache[feed] = { value: value, name: name, timestamp: timestamp || new Date().toISOString() };

  // update history
  if (!history[feed]) history[feed] = [];
  history[feed].push({ value: value, timestamp: timestamp });
  if (history[feed].length > HISTORY_MAX) history[feed].shift();

  // update marker popup and color based on thresholds
  const sensorDef = SENSORS.find(s => s.feed === feed);
  const marker = markerMap[feed];
  if (marker) {
    // ƒë·ªïi m√†u marker t√πy m·ª©c
    let color = "#0078ff", fill = "#00a6ff";
    if (sensorDef) {
      if (value >= sensorDef.danger) { color="#ff0000"; fill="#ff6666"; }
      else if (value >= sensorDef.warning) { color="#ff8c00"; fill="#ffc080"; }
      else { color="#0078ff"; fill="#00a6ff"; }
    }
    marker.setStyle({ color: color, fillColor: fill });
    marker.bindPopup(`<strong>${sensorDef ? sensorDef.name : (name || feed)}</strong><br>M·ª±c n∆∞·ªõc: <b>${value} cm</b><br><small>${new Date(timestamp).toLocaleString()}</small>`);
  }

  // N·∫øu sidebar ƒëang m·ªü cho ƒëi·ªÉm n√†y -> c·∫≠p nh·∫≠t UI realtime
  const currentName = document.getElementById("sensorName").innerText;
  if ((sensorDef && currentName === sensorDef.name) || (!sensorDef && currentName === (name || feed))) {
    renderGauge(sensorDef || { max_level: 100 }, value);
    if (sensorDef) renderStatus(sensorDef, value);
    if (sensorDef) renderInfluence(sensorDef, value);
    document.getElementById("lastUpdated").innerText = `C·∫≠p nh·∫≠t: ${new Date(timestamp).toLocaleString()}`;
    renderChart(feed);
  }
}

/* ===========================
   Start WebSocket
   =========================== */
connectWS();

/* ===========================
   OPTIONAL: Clean disconnect on page unload
   =========================== */
window.addEventListener("beforeunload", () => {
  try { if (socket) socket.close(); } catch(e) {}
});
</script>

</body>
</html>
