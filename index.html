<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Floodingmap</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- ApexCharts -->
<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>

<style>
    body { margin:0; padding:0; font-family:Arial; }
    #map { width: 100vw; height: 100vh; }

    /* SIDEBAR */
    #sidebar {
        position: fixed;
        top: 0;
        right: -420px;
        width: 420px;
        height: 100vh;
        background: #ffffff;
        border-left: 3px solid #000000;
        box-shadow: -4px 0 25px rgba(0,0,0,0.15);
        transition: 0.35s;
        padding: 0;
        z-index: 9999;
        display: flex;
        flex-direction: column;
    }
    #sidebar.active { right: 0; }

    #sidebarHeader {
        background: linear-gradient(135deg, #0078ff, #00a6ff);
        color: white;
        padding: 16px;
        font-size: 20px;
        font-weight: bold;
        display: flex; justify-content: space-between; align-items: center;
    }
    #closeBtn { cursor:pointer; font-size:22px; padding:2px 8px; background:rgba(255,255,255,0.3); border-radius:4px; }

    #sidebarContent { padding:20px; overflow-y:auto; }

    #toggleSidebar {
        position: fixed; top:20px; right:20px;
        background:#0078ff; color:white;
        padding:14px; border-radius:50%; cursor:pointer;
        z-index:10000; font-size:20px;
        box-shadow:0 4px 10px rgba(0,0,0,0.25);
        transition:0.25s;
    }
    #toggleSidebar:hover { transform:scale(1.1); }

    #searchBox { position:fixed; top:20px; left:20px; z-index:10000; }
    #searchInput {
        width:260px; padding:10px 14px;
        border-radius:10px; border:2px solid #0078ff;
        font-size:16px; outline:none;
    }

    /* Tooltip */
    .sensor-tooltip {
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 14px;
    }
</style>
</head>
<body>

<div id="toggleSidebar">â˜°</div>

<div id="searchBox">
    <input id="searchInput" placeholder="TÃ¬m Ä‘iá»ƒm Ä‘o..." />
</div>

<div id="map"></div>

<div id="sidebar">
    <div id="sidebarHeader">
        Chi tiáº¿t Ä‘iá»ƒm Ä‘o
        <span id="closeBtn">âœ•</span>
    </div>
    <div id="sidebarContent">
        <h2 id="sensorName"></h2>
        <div id="gaugeBox"></div>
        <p id="statusText"></p>
        <div id="chartBox" style="margin-top:25px;"></div>
    </div>
</div>

<script>
/* ==============================
   DANH SÃCH ÄIá»‚M ÄO
================================ */
const SENSORS = [
    { name:"Cáº§u Rá»“ng", lat:16.0605, lng:108.2237, min:20, mid:50, max:100, warning:60, danger:85 },
    { name:"Cáº§u SÃ´ng HÃ n", lat:16.0678, lng:108.2301, min:30, mid:50, max:100, warning:60, danger:85 }
];

let sensorValues = {};
let sensorHistory = {};
let currentSensor = null;
let influenceLayers = {};

/* ==============================
   MAP
================================ */
const map = L.map('map').setView([16.0678,108.2200],13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);

/* MARKERS & TOOLTIP */
SENSORS.forEach(point => {
    const marker = L.circleMarker([point.lat, point.lng], {
        radius: 10, color:"#0078ff", fillColor:"#00a6ff", fillOpacity:0.9
    }).addTo(map);

    marker.on("click", () => openSensor(point));

    // Khá»Ÿi táº¡o giÃ¡ trá»‹ vÃ  lá»‹ch sá»­
    sensorValues[point.name] = point.mid;
    sensorHistory[point.name] = [point.mid];

    // Tooltip hiá»ƒn thá»‹ má»±c nÆ°á»›c
    const tooltip = L.tooltip({
        permanent: true,
        direction: "top",
        className: "sensor-tooltip"
    }).setContent(`${point.name}: ${sensorValues[point.name].toFixed(1)} cm`)
      .setLatLng([point.lat, point.lng])
      .addTo(map);

    setInterval(() => {
        tooltip.setContent(`${point.name}: ${sensorValues[point.name].toFixed(1)} cm`);
    }, 1000);
});

/* ==============================
   Má»ž SIDEBAR â€“ HIá»‚N THá»Š Dá»® LIá»†U
================================ */
function openSensor(point) {
    currentSensor = point;
    toggleSidebar(true);
    document.getElementById("sensorName").innerText = point.name;

    const val = sensorValues[point.name];
    renderGauge(point, val);
    renderStatus(point, val);
    renderInfluence(point, val);
    renderChart(sensorHistory[point.name]);
}

/* ==============================
   VÃ’NG TRÃ’N áº¢NH HÆ¯á»žNG GRADIENT
================================ */
function renderInfluence(point, value) {
    if (influenceLayers[point.name])
        influenceLayers[point.name].forEach(c => map.removeLayer(c));

    const layers = [];
    const steps = 8;
    const maxRadius = 100 + (value / point.max) * 400;

    for (let i = 1; i <= steps; i++) {
        const opacity = 0.4 * (1 - i / steps);
        let color;
        if (value >= point.danger) color = `rgba(255,0,0,${opacity})`;
        else if (value >= point.warning) color = `rgba(255,165,0,${opacity})`;
        else color = `rgba(0,128,255,${opacity})`;

        layers.push(
            L.circle([point.lat, point.lng], {
                radius: (i / steps) * maxRadius,
                color, fillColor:color, fillOpacity:opacity, weight:1
            }).addTo(map)
        );
    }

    influenceLayers[point.name] = layers;
}

/* ==============================
   GAUGE & STATUS
================================ */
function renderGauge(point, value) {
    const percent = Math.round(value / point.max * 100);
    document.getElementById("gaugeBox").innerHTML = `
        <h3>Má»±c nÆ°á»›c: ${value.toFixed(1)} cm</h3>
        <h1 style="color:#0078ff; font-size:40px">${percent}%</h1>
    `;
}

function renderStatus(point, value) {
    let text, color;
    if (value >= point.danger) { text="âš ï¸ Nguy hiá»ƒm"; color="red"; }
    else if (value >= point.warning) { text="ðŸŸ¡ Cáº£nh bÃ¡o"; color="orange"; }
    else { text="ðŸŸ¢ An toÃ n"; color="green"; }

    document.getElementById("statusText").innerHTML =
        `<span style="color:${color}; font-size:18px; font-weight:bold;">${text}</span>`;
}

/* ==============================
   BIá»‚U Äá»’
================================ */
function renderChart(history) {
    const values = history.slice(-15);
    const times = values.map((v,i)=>`#${i}`);
    document.getElementById("chartBox").innerHTML = "";

    new ApexCharts(document.getElementById("chartBox"), {
        chart:{ type:"line", height:260 },
        series:[{ name:"Má»±c nÆ°á»›c", data:values }],
        xaxis:{ categories:times },
        stroke:{ width:3 }
    }).render();
}

/* ==============================
   SEARCH
================================ */
document.getElementById("searchInput").addEventListener("input", function () {
    const key = this.value.toLowerCase();
    const found = SENSORS.find(s => s.name.toLowerCase().includes(key));
    if (found) {
        map.setView([found.lat, found.lng], 15);
        openSensor(found);
    }
});

/* ==============================
   SIDEBAR TOGGLE
================================ */
const sidebar = document.getElementById("sidebar");
document.getElementById("toggleSidebar").onclick = () => toggleSidebar();
document.getElementById("closeBtn").onclick = () => toggleSidebar(false);

function toggleSidebar(force = null) {
    if (force === true) sidebar.classList.add("active");
    else if (force === false) sidebar.classList.remove("active");
    else sidebar.classList.toggle("active");
}

/* ==============================
   ANIMATION Má»°C NÆ¯á»šC MÆ¯á»¢T
================================ */
const sequence = [
    { duration: 30000, targets: [SENSORS[0].min, SENSORS[1].mid] }, // 0-2 phÃºt
    { duration: 30000, targets: [SENSORS[0].max, SENSORS[1].max] }, // 2-4 phÃºt
    { duration: 30000, targets: [SENSORS[0].mid, SENSORS[1].mid] }  // 4-6 phÃºt
];

let step = 0;
let startTime = null;
let startValues = [SENSORS[0].mid, SENSORS[1].mid];

function animate(timestamp) {
    if (!startTime) startTime = timestamp;
    const elapsed = timestamp - startTime;
    const { duration, targets } = sequence[step];

    const progress = Math.min(elapsed / duration, 1);

    SENSORS.forEach((point, i) => {
        const val = startValues[i] + (targets[i] - startValues[i]) * progress;
        sensorValues[point.name] = val;
        sensorHistory[point.name].push(val);
        if (sensorHistory[point.name].length > 50) sensorHistory[point.name].shift();

        renderInfluence(point, val);
        if (currentSensor && currentSensor.name === point.name) {
            renderGauge(point, val);
            renderStatus(point, val);
            renderChart(sensorHistory[point.name]);
        }
    });

    if (progress < 1) {
        requestAnimationFrame(animate);
    } else {
        step++;
        if (step < sequence.length) {
            startValues = SENSORS.map(p => sensorValues[p.name]);
            startTime = null;
            requestAnimationFrame(animate);
        }
    }
}

requestAnimationFrame(animate);
</script>

</body>
</html>
